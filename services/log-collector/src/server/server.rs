use crate::buffer_batcher::log_buffer_batcher::InMemoryBuffer;
use crate::helpers::log_processing::process_log_line;
use crate::parser::parser::NormalizedLog;
use crate::proto::collector::log_collector_server::LogCollector;
use crate::proto::common::{CollectResponse, RawLog};
use crate::shipper::shipper::Shipper;
use futures::StreamExt;
use std::pin::Pin;
use tokio::sync::mpsc;
use tokio_stream::wrappers::ReceiverStream;
use tonic::{Request, Response, Status, transport::Server};

#[derive(Debug, Default)]
pub struct LogCollectorService {
    pub parser: NormalizedLog,
    pub buffer_batcher: InMemoryBuffer,
    pub shipper: Shipper,
}

// Bind log collector application logic(LogCollectorService) to
// the gRPC service contract(LogCollector trait generated by Tonic
// from collector.proto).
//
// Translates the network requests and the Log Collector
// actual logic(modules).
#[tonic::async_trait]
impl log_collector_server::LogCollector for LogCollectorService {
    // The type of response stream the server will send back to the client calling it;
    //
    // Client sends a stream of incoming logs(RawLog messages).
    // The server sends the client back a stream of responses(CollectResponse messages).
    //
    // Basically how gRPC bi-directional streaming works in Log Collector server.
    type StreamLogStream =
        Pin<Box<dyn tokio_stream::Stream<Item = Result<CollectResponse, Status>> + Send>>;

    // Server side implementation of the RPC. Tonic calls this function automatically when
    // a client starts streaming logs to the Log Collector.
    //
    // 1. request: Request<tonic::Streaming<RawLog>> - this is how the log collector receives
    // incoming stream of RawLog messages.
    // 2. Result<Response<Self::StreamLogsStream>, Status> - this is what the Log Collector sends
    // back: a response that contains its outgoing stream.
    //
    // Basically, a client starts sending logs, and log collector starts replying as it processes them.
    async fn stream_log(
        &self,
        request: Request<tonic::Streaming<RawLog>>,
    ) -> Result<Response<Self::StreamLogStream>, Status> {
        // Extract the stream of RawLog messages from the request
        let inbound_log_stream = request.into_inner();

        // Create a channel to send CollectResponses back to the client calling the Log Collector
        let (tx, rx) = mpsc::channel(32);

        // Cloned references to modules(actual log collector logic) used by the Log Collector since self is &self
        let log_parser = self.parser.clone();
        let log_buffer_batcher = self.buffer_batcher.clone();
        let log_shipper = self.shipper.clone();

        // Spawn a background task to handle the incoming stream of logs
        tokio::spawn(async move {
            let mut inbound_logs = inbound_log_stream;
            while let Some(raw_log_result) = inbound_logs.next().await {
                match raw_log_result {
                    Ok(raw_log) => {
                        let line = raw_log.line;

                        // Actual log processing logic
                        match process_log_line(
                            &log_parser,
                            &log_buffer_batcher,
                            &log_shipper,
                            line.clone(),
                        )
                        .await
                        {
                            Ok(status) => {
                                let _ = tx.send(Ok(CollectResponse { status })).await;
                            }
                            Err(e) => {
                                eprintln!("Log processing error: {}", e);
                                let _ = tx
                                    .send(Ok(CollectResponse {
                                        status: format!("Error: {}", e),
                                    }))
                                    .await;
                            }
                        }
                    }
                    Err(e) => {
                        eprintln!("Error receiving log: {}", e);
                        let _ = tx
                            .send(Ok(CollectResponse {
                                status: format!("Stream error: {}", e),
                            }))
                            .await;
                    }
                }
            }
        });
        // Convert the receiver into a stream response.
        let response_stream = ReceiverStream::new(rx);
        Ok(Response::new(
            Box::pin(response_stream) as Self::StreamLogStream
        ))
    }
}
