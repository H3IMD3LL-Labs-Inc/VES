// Local crates
use crate::{
    buffer_batcher::log_buffer_batcher::InMemoryBuffer, helpers::log_processing::process_log_line,
    parser::parser::NormalizedLog, proto::collector::CollectResponse, proto::common::RawLog,
    shipper::shipper::Shipper,
};

// External crates
use futures::StreamExt;
use std::{pin::Pin, sync::Arc};
use tokio::sync::{Mutex, mpsc};
use tokio_stream::wrappers::ReceiverStream;
use tonic::{Request, Response, Status};
use tracing::instrument;

#[derive(Debug, Clone)]
pub struct LogCollectorService {
    pub parser: NormalizedLog,
    pub buffer_batcher: Arc<Mutex<InMemoryBuffer>>,
    pub shipper: Arc<Mutex<Shipper>>,
}

// Bind log collector application logic(LogCollectorService) to
// the gRPC service contract(LogCollector trait generated by Tonic
// from collector.proto).
//
// Translates the network requests and the Log Collector
// actual logic(modules).
#[tonic::async_trait]
impl crate::proto::collector::log_collector_server::LogCollector for LogCollectorService {
    // The type of response stream the server will send back to the client calling it
    //
    // Client sends a stream of incoming logs(RawLog messages).
    // The server sends the client back a stream of responses(CollectResponse messages).
    //
    // Basically how gRPC bi-directional streaming works in Log Collector server.
    type StreamLogStream =
        Pin<Box<dyn tokio_stream::Stream<Item = Result<CollectResponse, Status>> + Send>>;

    // Server side implementation of the RPC. Tonic calls this function automatically when
    // a client starts streaming logs to the Log Collector.
    //
    // 1. request: Request<tonic::Streaming<RawLog>> - this is how the log collector receives
    // incoming stream of RawLog messages.
    // 2. Result<Response<Self::StreamLogsStream>, Status> - this is what the Log Collector sends
    // back: a response that contains its outgoing stream.
    //
    // Basically, a client starts sending logs, and log collector starts replying as it processes them.
    #[instrument(
        name = "core_agent_rpc::stream_log",
        target = "server::server::streaming_rpc",
        skip_all,
        level = "debug"
    )]
    async fn stream_log(
        &self,
        request: Request<tonic::Streaming<RawLog>>,
    ) -> Result<Response<Self::StreamLogStream>, Status> {
        // Extract the stream of RawLog messages from the request
        let inbound_log_stream = request.into_inner();
        tracing::debug!(
            request_stream = ?inbound_log_stream,
            "Extracted unstructured observability data from request made to core agent"
        );

        tracing::debug!(
            channel_buffer_size = 32,
            "Creating channel to send CollectResponse back to client sending unstructured observability data to core agent"
        );
        // Create a channel to send CollectResponses back to the client calling the Log Collector
        let (tx, rx) = mpsc::channel(32);

        // Cloned references to modules(actual log collector logic) used by the Log Collector since self is &self
        let log_buffer_batcher = self.buffer_batcher.clone();
        let log_shipper = self.shipper.clone();

        tracing::debug!(
            "Spawning background asynchronous task to handle incoming unstructured observability data stream"
        );
        // Spawn a background task to handle the incoming stream of logs
        tokio::spawn(async move {
            let mut inbound_logs = inbound_log_stream;
            while let Some(raw_log_result) = inbound_logs.next().await {
                match raw_log_result {
                    Ok(raw_log) => {
                        let line = raw_log.raw_line;
                        let mut buffer = log_buffer_batcher.lock().await; // Acquire InMemoryBuffer lock to safely access shared InMemoryBuffer
                        let shipper = log_shipper.lock().await; // Acquire Shipper lock to safely access it
                        tracing::debug!(
                            unstructured_data = %line,
                            inmemory_buffer_lock = ?buffer,
                            shipper_lock = ?shipper,
                            "Acquiring InMemoryBuffer and Shipper locks before processing unstructured observability data received from stream"
                        );

                        // Actual log processing logic
                        match process_log_line(&mut *buffer, &*shipper, line.clone()).await {
                            Ok(_) => {
                                tracing::info!(
                                    unstructured_data = %line,
                                    "Successfully processed unstructured observability data received from stream"
                                );
                                let _ = tx.send(Ok(CollectResponse { accepted: true })).await;
                            }
                            Err(e) => {
                                tracing::error!(
                                    error = %e,
                                    unstructured_data = %line,
                                    "Error processing unstructured observability data received from stream"
                                );
                                let _ = tx.send(Ok(CollectResponse { accepted: false })).await;
                            }
                        }
                    }
                    Err(e) => {
                        // Network or stream error
                        tracing::error!(
                            error = %e,
                            "Error receiving unstructured observability data from stream"
                        );
                        let _ = tx.send(Ok(CollectResponse { accepted: false })).await;
                    }
                }
            }
        });
        // Convert the receiver into a stream response.
        let response_stream = ReceiverStream::new(rx);
        tracing::debug!(
            "Converting channel receiver background asynchronous task is writing into a response stream"
        );
        Ok(Response::new(
            Box::pin(response_stream) as Self::StreamLogStream
        ))
    }
}
